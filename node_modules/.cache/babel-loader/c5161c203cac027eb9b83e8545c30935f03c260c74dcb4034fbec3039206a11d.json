{"ast":null,"code":"import '../App.css';\n/**\n * プレビュー用canvas描画\n */\nexport async function getPng(text, font, color, borderColor, borderWidth) {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const canvas = document.createElement('canvas');\n      canvas.width = 128;\n      canvas.height = 128;\n      const textLine = text.split('\\n');\n      const fontSize = canvas.width / textLine.length;\n      const ctx = canvas.getContext('2d');\n      ctx.fillStyle = color;\n      ctx.strokeStyle = borderColor;\n      ctx.lineWidth = borderWidth;\n      ctx.lineJoin = 'round';\n      ctx.textBaseline = 'top';\n      ctx.font = `${fontSize}px '${font.name}', serif`;\n\n      // stroke\n      if (borderWidth > 0) {\n        textLine.forEach((line, i) => {\n          ctx.save();\n          //const lineWidth = ctx.measureText(line).width;\n          ctx.strokeText(line, canvas.width * 0.05, fontSize * 0.9 * i + fontSize * 0.05, canvas.width * 0.9);\n          ctx.restore();\n        });\n      }\n\n      // fill\n      textLine.forEach((line, i) => {\n        ctx.save();\n        ctx.fillText(line, canvas.width * 0.05, fontSize * 0.92 * i + fontSize * 0.05, canvas.width * 0.9);\n        ctx.restore();\n      });\n      const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n      for (var i = 0; i < data.length; i += 4) {\n        // データ4つでrgba 1px分\n        // 一番上の行から走査して最初に0以上の値が出てきたピクセルを確保\n        if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0 || data[i + 3] !== 0) {\n          break;\n        }\n      }\n      console.log(i);\n      resolve(canvas.toDataURL());\n    } catch (e) {\n      reject();\n    }\n  });\n}\n\n/**\n * Y軸オフセットを返す。\n * ブラウザによってy軸方向の描画がずれてるので計算する\n * @param canvas 絵文字が描画されたキャンバス\n * @returns Yオフセット\n */\nexport function getYOffset(font) {\n  try {\n    const canvas = document.createElement('canvas');\n    canvas.width = 128;\n    canvas.height = 128;\n    const fontSize = canvas.width;\n    const ctx = canvas.getContext('2d');\n    ctx.textBaseline = 'top';\n    ctx.font = `${fontSize}px '${font.name}', serif`;\n    ctx.save();\n    ctx.fillText(\"F\", canvas.width * 0.05, fontSize * 0.92 + fontSize * 0.05, canvas.width * 0.9);\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n    for (var i = 0; i < data.length; i += 4) {\n      // データ4つでrgba 1px分\n      // 一番上の行から走査して最初に0以上の値が出てきたピクセルを確保\n      if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0 || data[i + 3] !== 0) {\n        break;\n      }\n    }\n\n    // 一番上の行を計算\n    const yOffset = canvas.width % (i % 4);\n    console.log(i);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n    return yOffset;\n  } catch (e) {\n    throw e;\n  }\n}","map":{"version":3,"names":["getPng","text","font","color","borderColor","borderWidth","Promise","resolve","reject","canvas","document","createElement","width","height","textLine","split","fontSize","length","ctx","getContext","fillStyle","strokeStyle","lineWidth","lineJoin","textBaseline","name","forEach","line","i","save","strokeText","restore","fillText","data","getImageData","console","log","toDataURL","e","getYOffset","yOffset","clearRect"],"sources":["/Users/tadashi_o/ゆうた/other/pagesTest/src/utils/EmojiRenderer.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport '../App.css';\nimport { Font } from '../components/FontButton';\n\n/**\n * プレビュー用canvas描画\n */\nexport async function getPng(text: string, font: Font, color: string, borderColor: string, borderWidth: number): Promise<string> {\n  return new Promise(async (resolve, reject) => {\n    try {\n      const canvas = document.createElement('canvas');\n      canvas.width = 128;\n      canvas.height = 128;\n\n      const textLine = text.split('\\n');\n      const fontSize = canvas.width / textLine.length;\n\n      const ctx = canvas.getContext('2d')!;\n      ctx.fillStyle = color;\n      ctx.strokeStyle = borderColor;\n      ctx.lineWidth = borderWidth;\n      ctx.lineJoin = 'round';\n      ctx.textBaseline = 'top';\n      ctx.font = `${fontSize}px '${font.name}', serif`;\n\n      // stroke\n      if (borderWidth > 0) {\n        textLine.forEach((line, i) => {\n          ctx.save();\n          //const lineWidth = ctx.measureText(line).width;\n          ctx.strokeText(line, canvas.width * 0.05, (fontSize * 0.9 * i) + fontSize * 0.05, canvas.width * 0.9);\n          ctx.restore();\n        });\n      }\n\n      // fill\n      textLine.forEach((line, i) => {\n        ctx.save();\n        ctx.fillText(line, canvas.width * 0.05, (fontSize * 0.92 * i) + fontSize * 0.05, canvas.width * 0.9);\n        ctx.restore();\n      });\n\n      const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n      for (var i = 0; i < data.length; i += 4) {\n        // データ4つでrgba 1px分\n        // 一番上の行から走査して最初に0以上の値が出てきたピクセルを確保\n        if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0 || data[i + 3] !== 0) {\n          break;\n        }\n      }\n      console.log(i);\n\n      resolve(canvas.toDataURL());\n    } catch (e) {\n      reject();\n    }\n  });\n}\n\n/**\n * Y軸オフセットを返す。\n * ブラウザによってy軸方向の描画がずれてるので計算する\n * @param canvas 絵文字が描画されたキャンバス\n * @returns Yオフセット\n */\nexport function getYOffset(font: Font): number {\n    try {\n      const canvas = document.createElement('canvas');\n      canvas.width = 128;\n      canvas.height = 128;\n      const fontSize = canvas.width;\n      const ctx = canvas.getContext('2d')!;\n      ctx.textBaseline = 'top';\n      ctx.font = `${fontSize}px '${font.name}', serif`;\n      \n      ctx.save();\n      ctx.fillText(\"F\", canvas.width * 0.05, (fontSize * 0.92) + fontSize * 0.05, canvas.width * 0.9);\n      const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n\n      for (var i = 0; i < data.length; i += 4) {\n        // データ4つでrgba 1px分\n        // 一番上の行から走査して最初に0以上の値が出てきたピクセルを確保\n        if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0 || data[i + 3] !== 0) {\n          break;\n        }\n      }\n\n      // 一番上の行を計算\n      const yOffset = canvas.width % (i % 4);\n\n      console.log(i);\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.restore();\n\n\n      return yOffset;\n    } catch (e) {\n      throw e;\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}